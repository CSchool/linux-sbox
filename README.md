# linux-sbox
Sandboxing patch for Linux, based on ejudge one

## Включение безопасного режима работы процесса
Для включения безопасного режима работы используется системный вызов ptrace:
`ptrace(0x4281, 0, 0, 0)`

Здесь 0x4281 — «магическое» число - код запроса. Безопасный режим включается у текущего процесса. После включения безопасного режима процесс имеет право выполнить один системный вызов execve, то есть запустить на выполнение другую программу. Запускаемая программа будет работать в безопасном режиме, но уже не будет иметь право выполнять системный вызов exec.
При успешном завершении (то есть когда патч установлен в работающее ядро) системный вызов ptrace возвращает значение 0. Если патч не установлен, ptrace вернет значение -1, а переменная errno будет содержать код ошибки EINVAL.
## Установка ограничения времени работы процесса в миллисекундах
Для установки ограничения времени работы процесса в миллисекундах используется системный вызов setrlimit со специальным кодом ресурса.

struct rlimit lim;

lim.rlim_cur = mtime; // устанавливаем ограничение mtime миллисекунд

lim.rlim_max = mtime; // устанавливаем ограничение mtime миллисекунд

setrlimit(RLIMIT_MCPU, &lim);

Константа RLIMIT_MCPU определена в заголовочных файлах исходных кодов ядра Linux после применения патча. Однако, эта константа не определена в пользовательских заголовочных файлах стандартной библиотеки.

## Контроль ошибки Memory Limit Exceeded
Поведение системы в ситуации превышения лимита памяти процессом не отличается от стандартного, то есть:
если лимит памяти превышен при запуске программы (например, слишком большая область глобальных переменных), процесс снимается с выполнения посылкой ему сигнала SIGKILL (для непривилегированного участника это отображается как Run-time Error);
если лимит памяти превышен при работе со стеком (например, вследствии слишком глубокой рекурсии или слишком большой области локальных переменных), процесс снимается с выполнения посылкой ему сигнала SIGSEGV (для непривилегированного участника это отображается как Run-time Error);
если лимит памяти превыщен при выполнении системного вызова выделения памяти, такого как sbrk или mmap, системный вызов завершается с соответствующим кодом ошибки, и дальнейшая обработка ошибки возлагается на работающую программу.
Для включения диагностики ошибки Memory Limit Exceeded требуется выполнить системный вызов ptrace:
`ptrace(0x4280, 0, 0, 0)`

Здесь 0x4280 — «магическое» число - код запроса. После включения режима диагностики ошибки Memory Limit Exceeded в ситуации превышения лимита памяти процессом в любой из трех ситуаций ему посылается сигнал SIGKILL, и устанавливается специальный флаг. Это значит, что при включенной диагностике ошибки Memory Limit Exceeded программа не имеет возможность отреагировать на исчерпание памяти в куче.
Значение флага ошибки Memory Limit Exceeded можно получить с помощью системных вызовов семейства wait*. В слове состояния процесса (параметр status) устанавливается бит 0x10000, проверить который можно следующим образом:

wait(&status);

if ((status & 0x10000)) {

  // Memory Limit Exceeded
  
}

## Контроль ошибки Security Violation
Хотя в безопасном режиме все потенциально опасные системные вызовы запрещены, и программа не может нанести урона системе, может оказаться желательным отслеживать явные попытки выполнения опасных системных вызовов со стороны процесса. Например, если процесс пытается выполнить системный вызов fork, значит программа сознательно пытается нарушить функционирование системы, так как стандартная библиотека никогда не выполнит fork при выполнении безобидных операций (выделения памяти и пр.). С другой стороны, есть системные вызовы, такие как open, которые выполняются стандартной библиотекой неявно. Например, вызов некоторых (безобидных) функций стандартной библиотеки может привести к попытке открыть на чтение файл /etc/passwd.
Поэтому все запрещенные системные вызовы разделены на две группы: группу категорически запрещенных системных вызовов, попытка использования которых вызывает установку флага ошибки Security Violation, и группу остальных запрещенных системных вызовов.
Чтобы проверить, были ли в ходе выполнения процесса попытки выполнения категорически запрещенных системных вызовов, можно использовать следующий код:
wait(&status);

if ((status & 0x20000)) {

  // Security Violation
  
}

Так как стандартно в переменной status используется только младшие 16 бит, после проверки на ошибки Memory Limit Exceeded, Security Violation и Time-Limit Exceeded рекомендуется явно очистить старшие биты, чтобы гарантировать корректную работу макросов проверки статуса завершения процесса WIFEXITED и пр.
`status &= 0xffff;`
## Контроль ошибки Time-limit exceeded
Для включения диагностики ошибки time-limit exceeded требуется выполнить системный вызов ptrace:
`ptrace(0x4282, 0, 0, 0)`

Здесь 0x4282 — «магическое» число - код запроса.
В случае превышения максимального времени выполнения процесса ему посылается сигнал SIGKILL (как и в случае работы ядра Linux без патча), и дополнительно устанавливается флаг состояния процесса.
Чтобы проверить, было ли превышение времени работы, можно использовать следующий код:
wait(&status);

if ((status & 0x40000)) {

  // Time-limit Exceeded
  
}

Так как стандартно в переменной status используется только младшие 16 бит, после проверки на ошибки Memory Limit Exceeded, Security Violation и Time-Limit Exceeded рекомендуется явно очистить старшие биты, чтобы гарантировать корректную работу макросов проверки статуса завершения процесса WIFEXITED и пр.
`status &= 0xffff;`
